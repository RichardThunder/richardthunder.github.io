---
title: JVM 类加载机制
toc: true # 是否生成目录
indent: true # 是否首行缩进
archive: true # 是否显示在归档
cover: false # 是否显示封面
mathjax: false # 是否渲染公式
pin: false # 是否首页置顶
top_meta: false # 是否显示顶部信息
bottom_meta: false # 是否显示尾部信息
sidebar: [toc]
tag:
  - JVM
categories: JVM
keywords: 类加载
date: { { date } }
description: JVM类加载机制
icons: [fas fa-fire red, fas fa-star green]
---

# java 类加载机制

[TOC]

## 类的生命周期

类加载过程包括了 加载,验证,准备,解析,初始化五个阶段

其中 加载,验证,准备和初始化顺序是确定的,解析不一定 他可以在初始化阶段之后进行(为了支持 java 的动态绑定)

这些阶段是按顺序开始,并且互相交叉混合进行的,在一个阶段执行过程中调用或激活另一个阶段

![java_jvm_classload_2](/Users/richard/Downloads/java_jvm_classload_2.png)

## 类加载

加载阶段 jvm 的操作:

- 通过一个类的全想,定名来获取其定义的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法取得运行时数据结构
- 在 java 堆中生成一个代表这个类的 java.lang.Class 对象作为对方法区中这写数据的访问入口

![java_jvm_classload_1](/Users/richard/Downloads/java_jvm_classload_1.png)

加载阶段完成后虚拟机外部的二进制字节流就按照虚拟机所需格式存储在方法区中,而且在 java 堆中也创建一个 java.lang.Class 类的对象,这样便可以通过该对象访问方法区中的这些数据

类加载器必须在首次主动使用该类时才报告错误,如果这个类一直没有被主动使用,那么类加载器就不会报告错误

## 连接

### 验证:确保被加载类的正确性

为了确保 Class 文件的字节流包含的信息符合当桥虚拟机的要求,并且不会危害虚拟机自身的安全.其中包括 4 个阶段的检验动作:

- 文件格式验证 验证字节流是否符合 Class 文件格式规范,
- 元数据验证: 对字节码描述的信息进行语义分析以保证其描述的信息符合 java 语言规范的要求,例如这个类是否有父类
- 字节码验证: 通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的
- 符号引用验证:确保解析动作能正确执行

验证阶段非常重要,但不是必须的.他对程序运行期没有影响.

如果所引用的类经过反复验证,可以采用`-Xverifynone`关闭大部分的类验证措施,以缩短虚拟机类加载的时间

### 准备:为类的静态变量分配内存,并初始化为默认值

准备阶段是正是为变量分配内存并设置类变量初始值的阶段. 这些内存都将在方法区中分配

- 此时分配的内存仅包括类变量(static) 而不包括实例变量 实例变量会跟随对象实例化时随着对象一起在 java 堆中分配

- 这里设置的初始值一般(特殊情况下为常量会被直接赋为指定值)是数据类型默认的零值(0 0L null false) 而不是在代码中显式赋予的值

- 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。

- 对于同时被`static`和`final`修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。

- 对于引用数据类型`reference`来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即`null`

- 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。假设上面的类变量 value 被定义为: `public static final int value = 3；`编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为`static final`常量在编译期就将其结果放入了调用它的类的常量池中

### 解析:把类中的符号引用转换为直接引用

虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对`类`或`接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用点`限定符 7 类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

`直接引用`就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式:

- 声明类变量是指定初始值
- 使用静态代码块为类变量指定初始值

**JVM 初始化步骤**

- 假如这个类还没有被加载和连接，则程序先加载并连接该类
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类
- 假如类中有初始化语句，则系统依次执行这些初始化语句

**类初始化时机**: 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种:

- 创建类的实例，也就是 new 的方式
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射(如 Class.forName("com.pdai.jvm.Test"))
- 初始化某个类的子类，则其父类也会被初始化
- Java 虚拟机启动时被标明为启动类的类(Java Test)，直接使用 java.exe 命令来运行某个主类

### 使用

类访问方法区内的数据结构的接口， 对象是 Heap 区的数据。

### 卸载

**Java 虚拟机将结束生命周期的几种情况**

- 执行了 System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致 Java 虚拟机进程终止

## 类加载器的层次

![java_jvm_classload_3](/Users/richard/Downloads/java_jvm_classload_3.png)

这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。

对于 jvm,只存在两种不同的类加载器:

- 启动类加载器 C++实现(Hotspot)
- 所有的其他类加载器 这些类加载器都由 Java 语言实现，独立于虚拟机之外，并且全部继承自抽象类`java.lang.ClassLoader`，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。

对于开发者,类加载器分为三类:

- 启动类加载器 Bootstrap ClassLoader 负责加载存放在 JDK\jre\lib(JDK 代表 JDK 的安装目录，下同)下，或被-Xbootclasspath 参数指定的路径中的，并且能被虚拟机识别的类库(如 rt.jar，所有的 java.\*开头的类均被 Bootstrap ClassLoader 加载)。启动类加载器是无法被 Java 程序直接引用的
- 扩展类加载器 Extension ClassLoader 该加载器由`sun.misc.Launcher$ExtClassLoader`实现，它负责加载 JDK\jre\lib\ext 目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库(如 javax.\*开头的类)，开发者可以直接使用扩展类加载器。
- 应用程序类加载器 Application ClassLoader 该类加载由`sun.misc.Launcher$AppClassLoader`来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

如果编写了自己的 ClassLoader，便可以做到如下几点:

- 在执行非置信代码之前，自动验证数字签名。
- 动态地创建符合用户特定需要的定制化构建类。
- 从特定的场所取得 java class，例如数据库中和网络中。

## 类加载方式

类加载有三种方式:

- 命令行启动应用时由 JVM 初始化加载
- 通过 Class.forName()方法动态加载
- 通过 ClassLoader.loadClass()方法动态加载

- Class.forName(): 将类的.class 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 static 块；
- ClassLoader.loadClass(): 只干一件事情，就是将.class 文件加载到 jvm 中，不会执行 static 中的内容,只有在 newInstance 才会去执行 static 块。
- Class.forName(name, initialize, loader)带参函数也可控制是否加载 static 块。并且只有调用了 newInstance()方法采用调用构造函数，创建类的对象 。

## JVM 类加载机制

- `全盘负责` 加载某个 Class 时,该类加载器会加载该类所依赖和引用的其他 Class 除非正在使用另一个类加载器来载入
- `父类委托` 先让父类加载器试图加载该类.只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- `缓存机制` 保证所有加载过的类都会被缓存,当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效
- `双亲委派机制`, 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

1. 当 AppClassLoader 加载一个 class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。
2. 当 ExtClassLoader 加载一个 class 时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。
3. 如果 BootStrapClassLoader 加载失败(例如在$JAVA_HOME/jre/lib 里未查找到该 class)，会使用 ExtClassLoader 来尝试加载；
4. 若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常 ClassNotFoundException。

### **双亲委派优势**

- 系统类防止内存中出现多份同样的字节码
- 保证 Java 程序安全稳定运行
